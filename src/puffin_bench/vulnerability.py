from collections.abc import Callable
from dataclasses import dataclass
from pathlib import Path

from puffin_bench.puffin import Fuzzer, FuzzerProcess, FuzzerRun, Puffin, PuffinFuzzer
from puffin_bench.utils import ProcessResult


class Vulnerability:
    def __init__(self, vuln_id, name=None, cve=None) -> None:
        self._vuln_id = vuln_id
        self._name = name
        self._cve = cve

    def vuln_id(self):
        return self._vuln_id

    def name(self):
        return self._name if self._name else self._vuln_id

    def cve_name(self) -> str:
        return f"CVE-{self._cve}" if self._cve else ""

    def cve_url(self) -> str:
        return f"https://nvd.nist.gov/vuln/detail/{self.cve_name()}" if self._cve else ""

    def __str__(self) -> str:
        return self._vuln_id

    def __repr__(self) -> str:
        return f"{self.__class__!s}({self.__dict__!r})"

    def build(self, puffin: Puffin, out_dir: Path) -> "BuildResult":
        import subprocess

        target_dir = out_dir / "target"
        stdout_file = out_dir / "stdout.log"
        stderr_file = out_dir / "stderr.log"

        out_dir.mkdir(parents=True, exist_ok=True)
        stdout_file.unlink(missing_ok=True)
        stderr_file.unlink(missing_ok=True)

        cargo_flags: list[str] = []
        exec_flags: list[str] = []

        if self.vuln_id() == "SDOS1":
            cargo_flags = ["--features=openssl111j"]
        elif self.vuln_id() == "SIG":
            cargo_flags = ["--features=wolfssl510,fix-CVE-2022-25640,fix-CVE-2022-39173"]
        elif self.vuln_id() == "SKIP":
            cargo_flags = ["--features=wolfssl510,fix-CVE-2022-25638,fix-CVE-2022-39173"]
        elif self.vuln_id() == "SDOS2":
            cargo_flags = ["--features=wolfssl540,wolfssl-disable-postauth,fix-CVE-2022-39173"]
            exec_flags = ["--put-use-clear"]
        elif self.vuln_id() == "CDOS":
            cargo_flags = ["--features=wolfssl530,fix-CVE-2022-39173"]
        elif self.vuln_id() == "BUF":
            cargo_flags = ["--features=wolfssl540,fix-CVE-2022-42905"]
        elif self.vuln_id() == "HEAP":
            cargo_flags = ["--features=wolfssl540,asan,fix-CVE-2022-39173"]
        else:
            raise RuntimeError(f"Cannot build vulnerability {self.vuln_id()}")

        cmd = " ".join(
            [
                "cargo",
                "build",
                "--release",
                "--package=tlspuffin",
                f"--target-dir={target_dir}",
                *cargo_flags,
            ]
        )

        with open(stdout_file, "w") as fstdout, open(stderr_file, "w") as fstderr:
            process = subprocess.run(
                ["nix-shell", "--run", f"exec {cmd}"],
                cwd=puffin.repo,
                stdout=fstdout,
                stderr=fstderr,
                check=False,
            )

        if process.returncode == 0:
            return BuildResult.success(
                folder=out_dir,
                fuzzer=PuffinFuzzer(
                    puffin=puffin,
                    binary=puffin.repo / target_dir / "release" / "tlspuffin",
                    args=exec_flags,
                ),
            )
        else:
            return BuildResult.failure(folder=out_dir)


@dataclass
class BuildResult(ProcessResult):
    folder: Path
    fuzzer: Fuzzer
    is_success: bool

    @classmethod
    def success(cls, folder: Path, fuzzer: Fuzzer) -> "BuildResult":
        return cls(folder=folder, fuzzer=fuzzer, is_success=True)

    @classmethod
    def failure(cls, folder: Path) -> "BuildResult":
        return cls(folder=folder, fuzzer=cls.FailingFuzzer(), is_success=False)

    def stdout(self) -> str:
        stdout_file = self.folder / "stdout.log"
        if not stdout_file.exists():
            return ""

        return stdout_file.read_text()

    def stderr(self) -> str:
        stderr_file = self.folder / "stderr.log"
        if not stderr_file.exists():
            return ""

        return stderr_file.read_text()

    class FailingFuzzer(Fuzzer):
        def run(
            self,
            out_dir: Path,
            nb_cores: int,
            seed: bool,
            stop_on: Callable[[FuzzerProcess], bool],
        ) -> FuzzerRun:
            raise RuntimeError(
                f"Attempted to run a {self.__class__!s}, resulting from an invalid build."
            )
